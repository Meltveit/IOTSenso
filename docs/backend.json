{
  "entities": {
    "Sensor": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Sensor",
      "type": "object",
      "description": "Represents a sensor in the SensoGuard system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the sensor."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Sensor)"
        },
        "name": {
          "type": "string",
          "description": "Name of the sensor."
        },
        "location": {
          "type": "string",
          "description": "Location of the sensor."
        },
        "sensorType": {
          "type": "string",
          "description": "The type of sensor, e.g., temperature, humidity, pressure."
        },
        "warningThreshold": {
          "type": "number",
          "description": "Warning threshold for the sensor."
        },
        "criticalThreshold": {
          "type": "number",
          "description": "Critical threshold for the sensor."
        },
        "unit": {
          "type": "string",
          "description": "Unit of measurement for the sensor data, e.g., Celsius, Fahrenheit, PSI."
        }
      },
      "required": [
        "id",
        "userId",
        "name",
        "location",
        "sensorType",
        "warningThreshold",
        "criticalThreshold",
        "unit"
      ]
    },
    "SensorData": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SensorData",
      "type": "object",
      "description": "Represents a sensor data reading.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the sensor data reading."
        },
        "sensorId": {
          "type": "string",
          "description": "Reference to Sensor. (Relationship: Sensor 1:N SensorData)"
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of the sensor data reading.",
          "format": "date-time"
        },
        "value": {
          "type": "number",
          "description": "The value of the sensor data reading."
        }
      },
      "required": [
        "id",
        "sensorId",
        "timestamp",
        "value"
      ]
    },
    "Alert": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Alert",
      "type": "object",
      "description": "Represents an alert generated by the system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the alert."
        },
        "sensorId": {
          "type": "string",
          "description": "Reference to Sensor. (Relationship: Sensor 1:N Alert)"
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of when the alert was triggered.",
          "format": "date-time"
        },
        "alertLevel": {
          "type": "string",
          "description": "The level of the alert, e.g., warning, critical."
        },
        "message": {
          "type": "string",
          "description": "Message associated with the alert."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Alert)"
        },
        "acknowledged": {
          "type": "boolean",
          "description": "Indicates whether the alert has been acknowledged."
        }
      },
      "required": [
        "id",
        "sensorId",
        "timestamp",
        "alertLevel",
        "message",
        "userId",
        "acknowledged"
      ]
    },
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user in the SensoGuard system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        },
        "firstName": {
          "type": "string",
          "description": "First name of the user."
        },
        "lastName": {
          "type": "string",
          "description": "Last name of the user."
        },
        "phone": {
          "type": "string",
          "description": "The users phone number"
        }
      },
      "required": [
        "id",
        "email",
        "firstName",
        "lastName",
        "phone"
      ]
    },
    "PredictiveMaintenance": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PredictiveMaintenance",
      "type": "object",
      "description": "Represents a predictive maintenance record.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the predictive maintenance record."
        },
        "sensorId": {
          "type": "string",
          "description": "Reference to Sensor. (Relationship: Sensor 1:N PredictiveMaintenance)"
        },
        "predictedFailureTime": {
          "type": "string",
          "description": "The predicted time of failure.",
          "format": "date-time"
        },
        "probability": {
          "type": "number",
          "description": "The probability of failure."
        },
        "recommendation": {
          "type": "string",
          "description": "The recommended action to take."
        }
      },
      "required": [
        "id",
        "sensorId",
        "predictedFailureTime",
        "probability",
        "recommendation"
      ]
    },
    "Report": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Report",
      "type": "object",
      "description": "Represents a weekly sensor data report.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the report."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Report)"
        },
        "startDate": {
          "type": "string",
          "description": "Start date of the reporting period.",
          "format": "date-time"
        },
        "endDate": {
          "type": "string",
          "description": "End date of the reporting period.",
          "format": "date-time"
        },
        "summary": {
          "type": "string",
          "description": "Summary of the sensor data, average values, and alerts."
        },
        "reportFileUri": {
          "type": "string",
          "description": "URI to the report file.",
          "format": "uri"
        }
      },
      "required": [
        "id",
        "userId",
        "startDate",
        "endDate",
        "summary",
        "reportFileUri"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Collection to store user profiles.  Top-level collection to leverage Firebase Authentication.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user, obtained from Firebase Authentication."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/sensors/{sensorId}",
        "definition": {
          "entityName": "Sensor",
          "schema": {
            "$ref": "#/backend/entities/Sensor"
          },
          "description": "Collection to store sensors owned by a specific user.  Path-based ownership: Only the user with the matching userId can access sensors in this collection.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user, obtained from Firebase Authentication."
            },
            {
              "name": "sensorId",
              "description": "The unique identifier for the sensor."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/sensors/{sensorId}/sensorData/{sensorDataId}",
        "definition": {
          "entityName": "SensorData",
          "schema": {
            "$ref": "#/backend/entities/SensorData"
          },
          "description": "Collection to store sensor data readings for a specific sensor. Path-based ownership: Only the user with the matching userId can access sensor data in this collection.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user, obtained from Firebase Authentication."
            },
            {
              "name": "sensorId",
              "description": "The unique identifier for the sensor."
            },
            {
              "name": "sensorDataId",
              "description": "The unique identifier for the sensor data reading."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/alerts/{alertId}",
        "definition": {
          "entityName": "Alert",
          "schema": {
            "$ref": "#/backend/entities/Alert"
          },
          "description": "Collection to store alerts generated for a specific user.  Path-based ownership: Only the user with the matching userId can access alerts in this collection.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user, obtained from Firebase Authentication."
            },
            {
              "name": "alertId",
              "description": "The unique identifier for the alert."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/predictiveMaintenance/{predictiveMaintenanceId}",
        "definition": {
          "entityName": "PredictiveMaintenance",
          "schema": {
            "$ref": "#/backend/entities/PredictiveMaintenance"
          },
          "description": "Collection to store predictive maintenance records for a specific user. Path-based ownership: Only the user with the matching userId can access predictive maintenance records in this collection.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user, obtained from Firebase Authentication."
            },
            {
              "name": "predictiveMaintenanceId",
              "description": "The unique identifier for the predictive maintenance record."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/reports/{reportId}",
        "definition": {
          "entityName": "Report",
          "schema": {
            "$ref": "#/backend/entities/Report"
          },
          "description": "Collection to store reports generated for a specific user. Path-based ownership: Only the user with the matching userId can access reports in this collection.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user, obtained from Firebase Authentication."
            },
            {
              "name": "reportId",
              "description": "The unique identifier for the report."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to ensure security, scalability, and ease of debugging, following the principles of Authorization Independence, Clarity of Intent, DBAC, and QAPs. \n\n**Authorization Independence:**  The structure avoids hierarchical authorization dependencies by utilizing path-based ownership for private user data. For example, sensors, sensor data, alerts, reports, and predictive maintenance records are stored under the `/users/{userId}` collection, eliminating the need for `get()` calls in security rules and enabling atomic operations.\n\n**Structural Segregation:** Each collection is designed to maintain a homogeneous security posture.  All data within a user's path (`/users/{userId}/...`) is owned by that user.\n\n**Access Modeling:**\n*   **Private Data:** Path-based ownership is implemented using `/users/{userId}` as the root for user-owned data.\n*   **User-Owned Data:** Hierarchical paths like `/users/{userId}/sensors/{sensorId}` are used to represent `User 1:N Entity` relationships. This ensures clear ownership and simplifies security rules.\n\n**QAPs (Rules are not Filters):** List operations are secured by the path-based ownership.  A user can only list data under their own `/users/{userId}` path. This prevents unauthorized access to other users' data.\n\nThis structure prioritizes security, simplifies rules, and enhances debuggability by making authorization intent explicit through the use of clear path-based ownership."
  }
}