{
  "entities": {
    "Sensor": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Sensor",
      "type": "object",
      "description": "Represents a sensor in the SensoGuard system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the sensor."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Sensor)"
        },
        "name": {
          "type": "string",
          "description": "Name of the sensor."
        },
        "location": {
          "type": "string",
          "description": "Location of the sensor."
        },
        "sensorType": {
          "type": "string",
          "description": "The type of sensor, e.g., temperature, humidity, pressure."
        },
        "warningThreshold": {
          "type": "number",
          "description": "Warning threshold for the sensor."
        },
        "criticalThreshold": {
          "type": "number",
          "description": "Critical threshold for the sensor."
        },
        "unit": {
          "type": "string",
          "description": "Unit of measurement for the sensor data, e.g., Celsius, Fahrenheit, PSI."
        }
      },
      "required": [
        "id",
        "userId",
        "name",
        "location",
        "sensorType",
        "warningThreshold",
        "criticalThreshold",
        "unit"
      ]
    },
    "SensorData": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SensorData",
      "type": "object",
      "description": "Represents a sensor data reading.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the sensor data reading."
        },
        "sensorId": {
          "type": "string",
          "description": "Reference to Sensor. (Relationship: Sensor 1:N SensorData)"
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of the sensor data reading.",
          "format": "date-time"
        },
        "value": {
          "type": "number",
          "description": "The value of the sensor data reading."
        }
      },
      "required": [
        "id",
        "sensorId",
        "timestamp",
        "value"
      ]
    },
    "Alert": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Alert",
      "type": "object",
      "description": "Represents an alert generated by the system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the alert."
        },
        "sensorId": {
          "type": "string",
          "description": "Reference to Sensor. (Relationship: Sensor 1:N Alert)"
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of when the alert was triggered.",
          "format": "date-time"
        },
        "alertLevel": {
          "type": "string",
          "description": "The level of the alert, e.g., warning, critical."
        },
        "message": {
          "type": "string",
          "description": "Message associated with the alert."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Alert)"
        },
        "acknowledged": {
          "type": "boolean",
          "description": "Indicates whether the alert has been acknowledged."
        }
      },
      "required": [
        "id",
        "sensorId",
        "timestamp",
        "alertLevel",
        "message",
        "userId",
        "acknowledged"
      ]
    },
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user in the SensoGuard system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        },
        "firstName": {
          "type": "string",
          "description": "First name of the user."
        },
        "lastName": {
          "type": "string",
          "description": "Last name of the user."
        },
        "phone": {
          "type": "string",
          "description": "The users phone number"
        }
      },
      "required": [
        "id",
        "email",
        "firstName",
        "lastName",
        "phone"
      ]
    },
    "PredictiveMaintenance": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PredictiveMaintenance",
      "type": "object",
      "description": "Represents a predictive maintenance record.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the predictive maintenance record."
        },
        "sensorId": {
          "type": "string",
          "description": "Reference to Sensor. (Relationship: Sensor 1:N PredictiveMaintenance)"
        },
        "predictedFailureTime": {
          "type": "string",
          "description": "The predicted time of failure.",
          "format": "date-time"
        },
        "probability": {
          "type": "number",
          "description": "The probability of failure."
        },
        "recommendation": {
          "type": "string",
          "description": "The recommended action to take."
        }
      },
      "required": [
        "id",
        "sensorId",
        "predictedFailureTime",
        "probability",
        "recommendation"
      ]
    },
    "Report": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Report",
      "type": "object",
      "description": "Represents a weekly sensor data report.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the report."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Report)"
        },
        "startDate": {
          "type": "string",
          "description": "Start date of the reporting period.",
          "format": "date-time"
        },
        "endDate": {
          "type": "string",
          "description": "End date of the reporting period.",
          "format": "date-time"
        },
        "summary": {
          "type": "string",
          "description": "Summary of the sensor data, average values, and alerts."
        },
        "reportFileUri": {
          "type": "string",
          "description": "URI to the report file.",
          "format": "uri"
        }
      },
      "required": [
        "id",
        "userId",
        "startDate",
        "endDate",
        "summary",
        "reportFileUri"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Collection to store user profiles. Top-level collection to leverage Firebase Authentication.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user, obtained from Firebase Authentication."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/buildings/{buildingId}",
        "definition": {
          "entityName": "Building",
          "schema": {
            "$ref": "#/backend/entities/Building"
          },
          "description": "Subcollection to store buildings owned by a specific user.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "buildingId",
              "description": "The unique identifier for the building."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/sensors/{sensorId}",
        "definition": {
          "entityName": "Sensor",
          "schema": {
            "$ref": "#/backend/entities/Sensor"
          },
          "description": "Subcollection to store sensors owned by a specific user. Path-based ownership ensures security.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "sensorId",
              "description": "The unique identifier for the sensor."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/sensors/{sensorId}/sensorData/{sensorDataId}",
        "definition": {
          "entityName": "SensorData",
          "schema": {
            "$ref": "#/backend/entities/SensorData"
          },
          "description": "Subcollection to store sensor data readings for a specific sensor.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "sensorId",
              "description": "The unique identifier for the sensor."
            },
            {
              "name": "sensorDataId",
              "description": "The unique identifier for the sensor data reading."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/alerts/{alertId}",
        "definition": {
          "entityName": "Alert",
          "schema": {
            "$ref": "#/backend/entities/Alert"
          },
          "description": "Subcollection to store alerts for a specific user.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "alertId",
              "description": "The unique identifier for the alert."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/predictiveMaintenance/{predictiveMaintenanceId}",
        "definition": {
          "entityName": "PredictiveMaintenance",
          "schema": {
            "$ref": "#/backend/entities/PredictiveMaintenance"
          },
          "description": "Subcollection for predictive maintenance records.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "predictiveMaintenanceId",
              "description": "The unique identifier for the predictive maintenance record."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/reports/{reportId}",
        "definition": {
          "entityName": "Report",
          "schema": {
            "$ref": "#/backend/entities/Report"
          },
          "description": "Subcollection for user-specific reports.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "reportId",
              "description": "The unique identifier for the report."
            }
          ]
        }
      },
       {
        "path": "/available_sensors/{sensorId}",
        "definition": {
          "entityName": "AvailableSensor",
          "schema": {
            "$ref": "#/backend/entities/AvailableSensor"
          },
          "description": "Top-level collection for sensor inventory. Read-only for users.",
          "params": [
            {
              "name": "sensorId",
              "description": "The physical ID of the sensor."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is refactored to nest all user-specific data (buildings, sensors, alerts, etc.) under the `/users/{userId}` collection. This enforces path-based security, simplifies rules, and improves query performance and scalability. A top-level `available_sensors` collection is added for inventory management, with read-only access for authenticated users to prevent unauthorized modifications."
  }
}

    